import gmpy2
from gmpy2 import mpz
import time
from datetime import datetime
import csv

# =================== CONFIGURACIÓN ===================
ARCHIVO_PRIMOS = "primos.txt"
ARCHIVO_CSV = "resultados_goldbach.csv"
TIEMPO_MAX_ITERACION_MS = 1000
VERSION = "1.0021"
POTENCIA_INICIAL = 3
POTENCIA_FINAL = 100


# =====================================================

def cargar_primos(archivo: str) -> list:
    """Carga números primos desde un archivo de texto."""
    primos = []
    try:
        with open(archivo, 'r') as f:
            for linea in f:
                numero = linea.strip()
                if numero.isdigit():
                    primos.append(mpz(int(numero)))
    except FileNotFoundError:
        print(f"Error: Archivo '{archivo}' no encontrado.")
        exit()
    return primos


def evaluar_expresion(exponente: int) -> mpz:
    """Genera M = 10^exponente de forma simbólica."""
    return mpz(10) ** mpz(exponente)


def encontrar_pares_goldbach(M: mpz, primos: list) -> tuple:
    """Busca los primos P y Q que cumplen P + Q = M."""
    tiempo_inicio = time.perf_counter()
    iteraciones = 0
    error_msg = None
    P, Q = None, None

    try:
        for P_candidato in primos:
            if (time.perf_counter() - tiempo_inicio) * 1000 > TIEMPO_MAX_ITERACION_MS:
                raise TimeoutError(f"Tiempo excedido en M=10^{int(gmpy2.log10(M))}")

            iteraciones += 1
            Q_candidato = M - P_candidato
            if Q_candidato < 2:
                break

            if gmpy2.is_prime(Q_candidato):
                P, Q = int(P_candidato), int(Q_candidato)
                break

        if P is None:
            raise ValueError("Lista de primos insuficiente.")

    except Exception as e:
        error_msg = str(e)

    tiempo_ejecucion = (time.perf_counter() - tiempo_inicio) * 1000
    return P, Q, iteraciones, tiempo_ejecucion, error_msg


def ejecutar_bucle_y_generar_csv():
    """Ejecuta el bucle de pruebas y genera el CSV final."""
    resultados = []
    primos = cargar_primos(ARCHIVO_PRIMOS)

    print("\nIniciando validación de la Conjetura de Goldbach...")
    print(f"Rango: 10^{POTENCIA_INICIAL} (1,000) hasta 10^{POTENCIA_FINAL} (Googol)\n")

    for exponente in range(POTENCIA_INICIAL, POTENCIA_FINAL + 1):
        M = evaluar_expresion(exponente)
        log10_M = float(exponente)

        try:
            if M % 2 != 0 or M < 4:
                raise ValueError("M debe ser par y ≥4")

            P, Q, iteraciones, tiempo_ms, error = encontrar_pares_goldbach(M, primos)
            validacion = "TRUE" if error is None else "FALSE"

            resultados.append({
                "Fecha": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "Versión": VERSION,
                "M": f"10^{exponente}",
                "P": P,
                "Q": Q,
                "Iteraciones": iteraciones,
                "Tiempo (ms)": f"{tiempo_ms:.2f}",
                "Log10(M)": log10_M,
                "Validación": validacion,
                "Error": error
            })

            print(f"M=10^{exponente}: {validacion} | Iteraciones: {iteraciones} | Tiempo: {tiempo_ms:.2f} ms")

        except Exception as e:
            print(f"Error crítico en M=10^{exponente}: {str(e)}")

    # Generar CSV sin anotación de tipo redundante
    with open(ARCHIVO_CSV, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=[
            "Fecha", "Versión", "M", "P", "Q",
            "Iteraciones", "Tiempo (ms)", "Log10(M)", "Validación", "Error"
        ])
        writer.writeheader()
        writer.writerows(resultados)

    print(f"\n✅ CSV generado: '{ARCHIVO_CSV}'")


if __name__ == "__main__":
    print("=" * 60)
    print(f"Goldbach Conjecture Prover (Versión {VERSION})")
    print("=" * 60)

    inicio_total = time.perf_counter()
    ejecutar_bucle_y_generar_csv()
    tiempo_total = (time.perf_counter() - inicio_total) * 1000

    print(f"\n⏱️  Tiempo total de ejecución: {tiempo_total:.2f} ms")
    print("=" * 60)
